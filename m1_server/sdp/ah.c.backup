// ah.c - Accepting Host (Server) Orchestrator for SDP
#define _GNU_SOURCE // For asprintf
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <time.h>
#include <poll.h>   	// For proxy relay
#include <fcntl.h>  	// For pipe non-blocking or setting non-blocking sockets
#include <pcap.h>   	// For SPA Listener
#include <netinet/ip.h> // For IP header
#include <netinet/udp.h> // For UDP header
#include <ctype.h>       // For isspace
#include <stdarg.h>      // For va_list etc.
#include <endian.h>      // For htobe64 etc.

#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/rand.h>

#include "spa_common.h"
#include "ah_structs.h"

// --- Configuration & State Files ---
#define AH_STATE_FILE "ah_state.dat"
#define AH_ONBOARD_CONFIG "ah_onboard.conf"
#define EPH_CERT_DIR "/tmp/ah_eph_certs" // Directory to store received/generated certs

// --- Default Service Info ---
#define DEFAULT_TARGET_SERVICE_IP "10.9.65.55" // Where the actual service runs relative to AH
#define DEFAULT_TARGET_SERVICE_PORT 38472 	// Default SCTP port
#define SESSION_POLICY_TIMEOUT_SECONDS (SPA_DEFAULT_DURATION_SECONDS * 2) // How long policy lives
#define CLEANUP_INTERVAL_SECONDS 10

// --- Globals ---
volatile sig_atomic_t g_terminate_ah = 0;
ah_onboard_config_t g_ah_onboard_conf;
ah_state_t g_ah_state;
ah_session_policy_t *g_session_policies = NULL; // Head of linked list for active sessions
pthread_mutex_t g_policy_list_lock = PTHREAD_MUTEX_INITIALIZER;

// Controller Connection
SSL_CTX *g_controller_mtls_ctx = NULL; // Context for talking TO controller
SSL *g_controller_ssl = NULL;      	// Connection TO controller
pthread_mutex_t g_controller_ssl_lock = PTHREAD_MUTEX_INITIALIZER; // Protects g_controller_ssl access
pthread_t g_controller_listener_tid = 0;

// SPA Listener
pcap_t *g_spa_pcap_handle = NULL;
pthread_t g_spa_listener_tid = 0;

// Client mTLS Listener
int g_client_mtls_listen_sock = -1;
SSL_CTX *g_client_mtls_ctx = NULL; // Context for accepting client connections
pthread_t g_client_mtls_listener_tid = 0;

// Policy Cleanup Thread
pthread_t g_policy_cleanup_tid = 0;

// --- Forward Declarations ---
void sigint_handler_ah(int signo);
int load_ah_onboard_config(const char* filename, ah_onboard_config_t *conf);
int load_ah_state(const char* filename, ah_state_t *state);
int save_ah_state(const char* filename, const ah_state_t *state);
int execute_command_ah(const char* command_format, ...); // Similar to IH's execute_command
// REVISED PEM Helper Prototypes
const char* find_pem_start_ah(const char* line_buffer, const char* key_marker);
int save_pem_to_file_ah(const char* pem_start, const char* end_marker, const char* filename, mode_t mode);
// Controller Communication
void* controller_listener_thread(void* arg);
int process_controller_message(char *message_orig); // Takes original buffer
// Policy Management
int add_session_policy(const char* ih_ip, uint8_t proto, uint16_t port, uint16_t ah_listen_port,
                   	const unsigned char* enc, size_t el, const unsigned char* hmac, size_t hl,
                   	const unsigned char* hotp, size_t sl, uint64_t start_ctr,
                   	const char* ih_cert_pem_start, // Pointer to start of PEM in original buffer
                    const char* ah_cert_pem_start, // Pointer to start of PEM in original buffer
                    const char* ah_key_pem_start); // Pointer to start of PEM in original buffer
ah_session_policy_t* find_session_policy(const char* ih_ip); // Needs locking
void remove_session_policy(ah_session_policy_t *policy_to_remove); // Needs locking
void free_all_session_policies(); // Needs locking
void* policy_cleanup_thread(void* arg);
// SPA Listener
int run_ah_spa_listener(); // Starts the SPA listener thread
void spa_ah_packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet);
int run_iptables_rule_ah(const char* action, const char* source_ip, uint16_t target_port, const char* comment_tag);
// Client mTLS Listener & Relay
int run_client_mtls_listener(); // Starts the mTLS listener thread
SSL_CTX* create_ah_client_ssl_context();
void* handle_client_connection_thread(void* arg); // Handles one client mTLS connection
int relay_traffic(int sock_fd, SSL* ssl_conn, const char* target_ip, uint16_t target_port);
// Cleanup
void cleanup_ah_resources();

// --- Assumed external from spa_common.c (prototypes should be in spa_common.h) ---
extern void initialize_openssl();
extern void cleanup_openssl();
extern int send_spa_packet(const char*, uint16_t, const unsigned char*, const unsigned char*, size_t, const unsigned char*, size_t, uint64_t, uint8_t, uint16_t);
extern SSL_CTX* create_ssl_context(int);
extern int configure_ssl_context(SSL_CTX*, const char*, const char*, const char*, int);
extern SSL* establish_mtls_connection(const char*, uint16_t, SSL_CTX*);
extern int send_data_over_mtls(SSL*, const char*);
extern void handle_openssl_error(const char*);
extern const char* protocol_to_string(int);
extern int string_to_protocol(const char*);
extern char* trim_whitespace(char *str);
extern int hex_string_to_bytes(const char*, unsigned char*, size_t);
extern int constant_time_memcmp(const void*, const void*, size_t);
extern uint32_t generate_hotp(const unsigned char*, size_t, uint64_t, int);


// --- Implementations ---

void sigint_handler_ah(int signo) {
	if (g_terminate_ah == 0) {
    	g_terminate_ah = 1;
    	printf("\n[AH] Signal %d received, initiating shutdown...\n", signo);
    	// Break pcap loop (if running)
    	if (g_spa_pcap_handle) {
        	pcap_breakloop(g_spa_pcap_handle);
    	}
    	// Close listener sockets to interrupt accept() calls
    	if (g_client_mtls_listen_sock >= 0) {
            printf("[AH] Shutting down client listener socket...\n");
        	shutdown(g_client_mtls_listen_sock, SHUT_RDWR);
        	close(g_client_mtls_listen_sock);
        	g_client_mtls_listen_sock = -1;
    	}
    	// Optionally signal threads more directly if needed (e.g., pipes)
	}
}

// Load AH onboarding config (Similar to IH's load_onboarding_config)
int load_ah_onboard_config(const char* filename, ah_onboard_config_t *conf) {
   FILE *fp = fopen(filename, "r"); if (!fp) { perror("[AH] Open AH onboard"); return 0; } printf("[AH] Loading onboard: %s\n", filename); memset(conf, 0, sizeof(ah_onboard_config_t)); char line[1024]; int ln=0, in_s=0;
   while(fgets(line,sizeof(line),fp)){ ln++; char*t=trim_whitespace(line); if(!t||t[0]=='\0'||t[0]=='#')continue; if(t[0]=='['&&t[strlen(t)-1]==']'){ size_t il=strlen(t)-2; if(il>0&&il<INET_ADDRSTRLEN){strncpy(conf->controller_ip,t+1,il);conf->controller_ip[il]='\0';struct sockaddr_in sa;if(inet_pton(AF_INET,conf->controller_ip,&sa.sin_addr)!=1){fprintf(stderr, "[AH] Invalid Ctrl IP line %d\n", ln); fclose(fp);return 0;}in_s=1;printf("[AH] Config for Controller IP: %s\n",conf->controller_ip);}else{fprintf(stderr,"[AH] Invalid header line %d\n", ln);fclose(fp);return 0;}} else if(in_s){char*k=t,*v=NULL;for(char*p=k;*p!='\0';++p){if(isspace((unsigned char)*p)||*p=='='){*p='\0';v=p+1;while(*v!='\0'&&(isspace((unsigned char)*v)||*v=='=')){v++;}break;}} if(v&&*v!='\0'){k=trim_whitespace(k);char*c=strchr(v,'#');if(c)*c='\0';v=trim_whitespace(v);if(strlen(k)==0||strlen(v)==0)continue; if(strcasecmp(k,"ENCRYPTION_KEY")==0){int l=hex_string_to_bytes(v,conf->enc_key,MAX_KEY_LEN);if(l>0){conf->enc_key_len=l;conf->has_enc=1;}else{fprintf(stderr, "[AH] Invalid ENC key line %d\n", ln);fclose(fp);return 0;}} else if(strcasecmp(k,"HMAC_KEY")==0){int l=hex_string_to_bytes(v,conf->hmac_key,MAX_KEY_LEN);if(l>0){conf->hmac_key_len=l;conf->has_hmac=1;}else{fprintf(stderr, "[AH] Invalid HMAC key line %d\n", ln);fclose(fp);return 0;}} else if(strcasecmp(k,"HOTP_SECRET")==0){int l=hex_string_to_bytes(v,conf->hotp_secret,MAX_KEY_LEN);if(l>0){conf->hotp_secret_len=l;conf->has_hotp=1;}else{fprintf(stderr, "[AH] Invalid HOTP key line %d\n", ln);fclose(fp);return 0;}} else if(strcasecmp(k,"CA_CERT_PATH")==0){strncpy(conf->ca_cert_path,v,sizeof(conf->ca_cert_path)-1);conf->has_ca=1;} else if(strcasecmp(k,"CLIENT_CERT_PATH")==0){strncpy(conf->client_cert_path,v,sizeof(conf->client_cert_path)-1);conf->has_cert=1;} else if(strcasecmp(k,"CLIENT_KEY_PATH")==0){strncpy(conf->client_key_path,v,sizeof(conf->client_key_path)-1);conf->has_key=1;} else if(strcasecmp(k,"MY_IP")==0){strncpy(conf->my_ip,v,sizeof(conf->my_ip)-1);conf->has_my_ip=1;} else {fprintf(stderr,"[AH] Warn: Unknown key %s L%d\n",k,ln);}}}}
   fclose(fp); if(!conf->has_enc||!conf->has_hmac||!conf->has_hotp||!conf->has_ca||!conf->has_cert||!conf->has_key||!conf->has_my_ip||strlen(conf->controller_ip)==0){fprintf(stderr,"[AH] Missing fields in %s\n",filename);return 0;} printf("[AH] AH Onboard loaded OK.\n"); return 1;
}


// AH State Load/Save (Simpler than IH, only Controller counter)
int load_ah_state(const char* fn, ah_state_t *s){ FILE *fp=fopen(fn,"rb"); if(!fp){ printf("[AH] State file '%s' not found, initializing counters to 0.\n", fn); s->controller_hotp_counter=0;return 1;} if(fread(s,sizeof(ah_state_t),1,fp)!=1){ perror("[AH] Error reading state file"); fclose(fp);s->controller_hotp_counter=0;return 0;} fclose(fp);printf("[AH] Loaded AH state CtrlCtr=%llu\n",(unsigned long long)s->controller_hotp_counter);return 1;}
int save_ah_state(const char* fn, const ah_state_t *s){ FILE *fp=fopen(fn,"wb"); if(!fp){perror("[AH] Error opening state file for writing"); return 0;} if(fwrite(s,sizeof(ah_state_t),1,fp)!=1){perror("[AH] Error writing state file"); fclose(fp);return 0;} fclose(fp);printf("[AH] Saved AH state CtrlCtr=%llu\n",(unsigned long long)s->controller_hotp_counter);return 1;}

// Execute Command (Needs sudo for iptables)
int execute_command_ah(const char* command_format, ...) {
   va_list args; char *command = NULL; int sys_ret = -1, exit_status = -1;
   va_start(args, command_format);
   if (vasprintf(&command, command_format, args) == -1) { perror("[AH] vasprintf"); va_end(args); return -1; }
   va_end(args); printf("[AH] Executing: %s\n", command);
   sys_ret = system(command);
   if (sys_ret == -1) { perror("[AH] system() failed"); exit_status = -1;}
   else {
   	if (WIFEXITED(sys_ret)) { exit_status = WEXITSTATUS(sys_ret); }
   	else if (WIFSIGNALED(sys_ret)) { fprintf(stderr, "[AH] Command killed signal: %d\n", WTERMSIG(sys_ret)); exit_status = -2; }
   	else { exit_status = -3; } // Other non-exit status
   }
   free(command);
   return exit_status; // Return exit status or negative error
}


// --- PEM Parsing Helpers ---

// REVISED find_pem_start_ah: Searches for "-----BEGIN" AFTER the key marker on the given line.
const char* find_pem_start_ah(const char* line_buffer, const char* key_marker) {
    if (!line_buffer || !key_marker) return NULL;

    // Find the colon separating key and value
    const char* value_start = strchr(line_buffer, ':');
    if (!value_start) return NULL;
    value_start++; // Move past the colon

    // Now search for the standard PEM beginning marker within the rest of the line
    return strstr(value_start, "-----BEGIN");
}


// Saves PEM data (from pem_start up to and including end_marker) to a file.
int save_pem_to_file_ah(const char* pem_start, const char* end_marker, const char* filename, mode_t mode) {
   if (!pem_start || !end_marker || !filename) return 0;
   const char* pem_end = strstr(pem_start, end_marker);
   if (!pem_end) { fprintf(stderr, "[AH] Error: Could not find PEM end marker '%s' for file %s\n", end_marker, filename); return 0; }
   pem_end += strlen(end_marker); // Include the end marker itself
   // Consume trailing newline/whitespace
   while (*pem_end == '\r' || *pem_end == '\n' || isspace((unsigned char)*pem_end)) { pem_end++; }
   size_t pem_len = pem_end - pem_start;
   if (pem_len <= 0) { fprintf(stderr, "[AH] Error: Zero or negative PEM length for %s\n", filename); return 0; }


   // Ensure directory exists
   char *dir_sep = strrchr(filename, '/');
   if (dir_sep) {
    	char dir_path[256];
        size_t dir_len = dir_sep - filename;
        if (dir_len >= sizeof(dir_path)) { fprintf(stderr, "[AH] Error: Cert directory path too long: %s\n", filename); return 0; }
    	strncpy(dir_path, filename, dir_len);
    	dir_path[dir_len] = '\0';
    	// Use mkdir -p semantics (mode 0700)
    	struct stat st = {0};
    	if (stat(dir_path, &st) == -1) {
            printf("[AH] Creating directory: %s\n", dir_path);
         	if (mkdir(dir_path, 0700) == -1 && errno != EEXIST) { // Allow EEXIST
             	perror("[AH] mkdir for certs failed");
             	return 0;
         	}
    	}
   }

   FILE* fp = fopen(filename, "w");
   if (!fp) { perror("[AH] fopen PEM failed"); fprintf(stderr, "[AH] Could not open %s for writing\n", filename); return 0; }
   if (fwrite(pem_start, 1, pem_len, fp) != pem_len) {
   	perror("[AH] fwrite PEM failed"); fclose(fp); remove(filename); return 0;
   }
   fclose(fp);
   if (chmod(filename, mode) == -1) { perror("[AH] chmod PEM failed"); /* Non-fatal? */ }
   printf("[AH]   Saved PEM data to %s (%zu bytes)\n", filename, pem_len);
   return 1;
}


// --- Controller Connection and Listener ---
void* controller_listener_thread(void* arg) {
	(void)arg; // Unused
	char buffer[8192]; // Buffer for messages from controller
	int read_len;
	fd_set read_fds;
	struct timeval timeout;

	printf("[AH_CtrlComm] Controller listener thread started.\n");

	while (!g_terminate_ah) {
    	pthread_mutex_lock(&g_controller_ssl_lock);
    	if (!g_controller_ssl) {
        	pthread_mutex_unlock(&g_controller_ssl_lock);
        	// printf("[AH_CtrlComm] No active connection to Controller. Sleeping...\n"); // Reduce verbosity
        	sleep(5); // Wait before retrying connection setup
        	// TODO: Implement reconnection logic here or in main loop
        	continue;
    	}

    	SSL *current_ssl = g_controller_ssl; // Work with local copy inside lock scope
    	int current_fd = SSL_get_fd(current_ssl);
    	pthread_mutex_unlock(&g_controller_ssl_lock); // Unlock after getting FD

        // Check if FD is valid before using in select
        if (current_fd < 0) {
             printf("[AH_CtrlComm] Controller SSL connection FD is invalid. Waiting...\n");
             sleep(5);
             continue;
        }

    	FD_ZERO(&read_fds);
    	FD_SET(current_fd, &read_fds);
    	timeout.tv_sec = 2; // Check for data every 2 seconds
    	timeout.tv_usec = 0;

    	int activity = select(current_fd + 1, &read_fds, NULL, NULL, &timeout);

    	if (g_terminate_ah) break; // Check termination flag after select

    	if (activity < 0) {
        	if (errno == EINTR) continue; // Interrupted by signal (e.g., SIGINT handled)
            if (errno == EBADF) { // Socket closed likely by another thread/cleanup
                printf("[AH_CtrlComm] Controller socket closed (EBADF in select).\n");
                // Ensure global SSL is marked as NULL
                pthread_mutex_lock(&g_controller_ssl_lock);
                if (g_controller_ssl == current_ssl) g_controller_ssl = NULL;
                pthread_mutex_unlock(&g_controller_ssl_lock);
                continue;
            }
        	perror("[AH_CtrlComm] select error");
        	// Assume connection is dead, trigger cleanup/reconnect
        	pthread_mutex_lock(&g_controller_ssl_lock);
        	if (g_controller_ssl == current_ssl) { // Check if it wasn't already closed
                printf("[AH_CtrlComm] Closing controller connection due to select error.\n");
                // SSL_free also closes the underlying FD
                SSL_free(g_controller_ssl);
            	g_controller_ssl = NULL;
        	}
        	pthread_mutex_unlock(&g_controller_ssl_lock);
        	continue; // Try to reconnect later
    	}

    	if (activity == 0) {
        	// Timeout - no data, connection likely still okay. Loop.
        	continue;
    	}

    	// Data available or connection closed/error
    	if (FD_ISSET(current_fd, &read_fds)) {
         	pthread_mutex_lock(&g_controller_ssl_lock);
         	if (g_controller_ssl != current_ssl || g_controller_ssl == NULL) { // Conn changed or closed while waiting
             	pthread_mutex_unlock(&g_controller_ssl_lock);
             	continue;
         	}
         	// Use non-blocking read first (SSL_read with non-blocking socket can return WANT_READ/WRITE)
         	// For simplicity with blocking socket after select:
         	read_len = SSL_read(g_controller_ssl, buffer, sizeof(buffer) - 1);

         	if (read_len > 0) { // Data received
             	buffer[read_len] = '\0';
             	printf("[AH_CtrlComm] Received %d bytes from Controller:\n---\n%s\n---\n", read_len, buffer);
             	// Process the message
             	process_controller_message(buffer);
         	} else { // read_len <= 0: Error or clean close
                 int ssl_err = SSL_get_error(g_controller_ssl, read_len);
                 if (ssl_err == SSL_ERROR_ZERO_RETURN) {
                     printf("[AH_CtrlComm] Controller closed the connection cleanly.\n");
                 } else if (ssl_err == SSL_ERROR_SYSCALL && read_len == 0) {
                     printf("[AH_CtrlComm] Controller closed connection (EOF).\n");
                 } else if (ssl_err == SSL_ERROR_SYSCALL) {
                     perror("[AH_CtrlComm] Controller connection syscall error");
                 } else {
                    fprintf(stderr, "[AH_CtrlComm] Controller connection SSL_read error: %d\n", ssl_err);
                    handle_openssl_error("Controller SSL_read");
                 }
                 // Close connection on error or closure
                 SSL_free(g_controller_ssl); // SSL_free handles shutdown and closes FD
                 g_controller_ssl = NULL;
             }
         	pthread_mutex_unlock(&g_controller_ssl_lock);

    	} // end if FD_ISSET
	} // end while !g_terminate_ah

	printf("[AH_CtrlComm] Controller listener thread exiting.\n");
	return NULL;
}


// Process messages received from the controller (NEW_SESSION) - REVISED PARSING
int process_controller_message(char *message_orig) {
    if (strncmp(message_orig, "NEW_SESSION", 11) != 0) {
        fprintf(stderr, "[AH] Warn: Received unknown message type from controller.\n");
        return 0; // Not the message we expect
    }
    printf("[AH] Processing NEW_SESSION directive from Controller.\n");

    char ih_ip[INET_ADDRSTRLEN] = {0};
    uint8_t service_proto = 0;
    uint16_t service_port = 0;
    unsigned char spa_enc[MAX_KEY_LEN] = {0}; size_t el = 0;
    unsigned char spa_hmac[MAX_KEY_LEN] = {0}; size_t hl = 0;
    unsigned char hotp_sec[MAX_KEY_LEN] = {0}; size_t sl = 0;
    uint64_t start_ctr = 0;

    // Pointers into the ORIGINAL message buffer where PEM data starts
    const char *ih_cert_pem_start_in_orig = NULL;
    const char *ah_cert_pem_start_in_orig = NULL;
    const char *ah_key_pem_start_in_orig = NULL;

    char *current_line = message_orig;
    char *next_line = NULL;

    // Find start after "NEW_SESSION\n"
    current_line = strchr(message_orig, '\n');
    if (!current_line) return 0; // Malformed
    current_line++; // Move past newline

    while (current_line != NULL && *current_line != '\0') {
        next_line = strchr(current_line, '\n');
        size_t line_len;
        if (next_line) {
            line_len = next_line - current_line;
            *next_line = '\0'; // Temp null-terminate
        } else {
            line_len = strlen(current_line);
        }

        // Skip empty lines that might result from extra newlines in PEM data
        if (line_len == 0 || *current_line == '\r') {
             if (next_line) { *next_line = '\n'; current_line = next_line + 1; } else { current_line = NULL;}
             continue;
        }

        char *line_copy = strndup(current_line, line_len); // Work on a copy
        if (!line_copy) { perror("strndup"); if(next_line) *next_line = '\n'; return 0; }

        if (strncmp(line_copy, "END_SESSION", 11) == 0) {
            free(line_copy);
            if (next_line) *next_line = '\n';
            break;
        }

        char *key = line_copy;
        char *value = strchr(key, ':');

        if (value) {
            *value = '\0'; value++;
            key = trim_whitespace(key);
            value = trim_whitespace(value);

            // --- Parse Simple Key/Value Pairs ---
            if (strcasecmp(key, "IH_IP") == 0) { strncpy(ih_ip, value, sizeof(ih_ip)-1); }
            else if (strcasecmp(key, "SERVICE_PROTO") == 0) { service_proto = (uint8_t)atoi(value); }
            else if (strcasecmp(key, "SERVICE_PORT") == 0) { service_port = (uint16_t)atoi(value); }
            else if (strcasecmp(key, "SPA_ENC_KEY") == 0) { el = hex_string_to_bytes(value, spa_enc, MAX_KEY_LEN); }
            else if (strcasecmp(key, "SPA_HMAC_KEY") == 0) { hl = hex_string_to_bytes(value, spa_hmac, MAX_KEY_LEN); }
            else if (strcasecmp(key, "HOTP_SECRET") == 0) { sl = hex_string_to_bytes(value, hotp_sec, MAX_KEY_LEN); }
            else if (strcasecmp(key, "HOTP_COUNTER") == 0) { start_ctr = strtoull(value, NULL, 10); }
            // --- Store pointers to the start of PEM data IN THE ORIGINAL BUFFER ---
            // Pass the ORIGINAL line ('current_line') to find_pem_start_ah
            else if (strcasecmp(key, "IH_EPH_CERT") == 0) { ih_cert_pem_start_in_orig = find_pem_start_ah(current_line, "IH_EPH_CERT:"); }
            else if (strcasecmp(key, "AH_EPH_CERT") == 0) { ah_cert_pem_start_in_orig = find_pem_start_ah(current_line, "AH_EPH_CERT:"); }
            else if (strcasecmp(key, "AH_EPH_KEY") == 0)  { ah_key_pem_start_in_orig = find_pem_start_ah(current_line, "AH_EPH_KEY:"); }
        }

        free(line_copy); // Free the duplicated line

        if (next_line) {
            *next_line = '\n'; // Restore newline
            current_line = next_line + 1;
        } else {
            current_line = NULL; // Reached end
        }
    }

    // --- Validate required fields ---
    int parse_ok = (strlen(ih_ip) > 0 && service_proto > 0 && el > 0 && hl > 0 && sl > 0 &&
                    ih_cert_pem_start_in_orig != NULL &&
                    ah_cert_pem_start_in_orig != NULL &&
                    ah_key_pem_start_in_orig != NULL);

    printf("[AH] Parse results: IH_IP=%d SP=%d EL=%d HL=%d SL=%d IHC=%d AHC=%d AHK=%d\n",
            strlen(ih_ip)>0, service_proto>0, el>0, hl>0, sl>0,
            ih_cert_pem_start_in_orig != NULL,
            ah_cert_pem_start_in_orig != NULL,
            ah_key_pem_start_in_orig != NULL);

    if (!parse_ok) {
        fprintf(stderr, "[AH] Error: Incomplete NEW_SESSION directive received after parsing.\n");
        return 0;
    }

    // --- Add the policy (pass the pointers found in the original buffer) ---
    if (!add_session_policy(ih_ip, service_proto, service_port, AH_MTLS_PORT_DEFAULT,
                            spa_enc, el, spa_hmac, hl, hotp_sec, sl, start_ctr,
                            ih_cert_pem_start_in_orig, // Pointer to IH cert PEM start
                            ah_cert_pem_start_in_orig, // Pointer to AH cert PEM start
                            ah_key_pem_start_in_orig)) // Pointer to AH key PEM start
    {
        fprintf(stderr, "[AH] Failed to add session policy for IH %s\n", ih_ip);
        return 0;
    }

    printf("[AH] Successfully processed NEW_SESSION for IH %s targeting %s/%u\n",
           ih_ip, protocol_to_string(service_proto), service_port);
    return 1;
}


// Add a new session policy to the list
int add_session_policy(const char* ih_ip, uint8_t proto, uint16_t port, uint16_t ah_listen_port,
                   	const unsigned char* enc, size_t el, const unsigned char* hmac, size_t hl,
                   	const unsigned char* hotp, size_t sl, uint64_t start_ctr,
                   	const char* ih_cert_pem_start, const char* ah_cert_pem_start, const char* ah_key_pem_start)
{
	printf("[AH_Policy] Adding policy for IH: %s (Service: %u/%u, Listen Port: %u)\n",
       	ih_ip, proto, port, ah_listen_port);

	ah_session_policy_t *new_policy = malloc(sizeof(ah_session_policy_t));
	if (!new_policy) { perror("malloc session policy"); return 0; }
	memset(new_policy, 0, sizeof(ah_session_policy_t));

	strncpy(new_policy->ih_ip, ih_ip, sizeof(new_policy->ih_ip)-1);
	new_policy->service_proto = proto;
	new_policy->service_port = port;
	new_policy->ah_mtls_listen_port = ah_listen_port;
	strncpy(new_policy->target_service_ip, DEFAULT_TARGET_SERVICE_IP, sizeof(new_policy->target_service_ip)-1);
	new_policy->target_service_port = DEFAULT_TARGET_SERVICE_PORT; // Use configured default

	memcpy(new_policy->spa_enc_key, enc, el); new_policy->spa_enc_key_len = el;
	memcpy(new_policy->spa_hmac_key, hmac, hl); new_policy->spa_hmac_key_len = hl;
	memcpy(new_policy->hotp_secret, hotp, sl); new_policy->hotp_secret_len = sl;
	new_policy->hotp_next_counter = start_ctr; // Should be 0 usually

	new_policy->expiry_time = time(NULL) + SESSION_POLICY_TIMEOUT_SECONDS;
	new_policy->active = 0; // Not active until mTLS is established

	// Construct filenames (ensure directory exists - done in save_pem)
	snprintf(new_policy->ih_eph_cert_path, sizeof(new_policy->ih_eph_cert_path),
         	"%s/ih_eph_%s.crt", EPH_CERT_DIR, ih_ip);
	snprintf(new_policy->ah_eph_cert_path, sizeof(new_policy->ah_eph_cert_path),
         	"%s/ah_eph_%s_for_ih_%s.crt", EPH_CERT_DIR, g_ah_onboard_conf.my_ip, ih_ip);
	snprintf(new_policy->ah_eph_key_path, sizeof(new_policy->ah_eph_key_path),
         	"%s/ah_eph_%s_for_ih_%s.key", EPH_CERT_DIR, g_ah_onboard_conf.my_ip, ih_ip);

	// Save PEM data to files using pointers to start of PEM data
	int ok = 1;
	if (!save_pem_to_file_ah(ih_cert_pem_start, "-----END CERTIFICATE-----", new_policy->ih_eph_cert_path, 0644)) ok = 0;
	if (ok && !save_pem_to_file_ah(ah_cert_pem_start, "-----END CERTIFICATE-----", new_policy->ah_eph_cert_path, 0644)) ok = 0;
	if (ok && !save_pem_to_file_ah(ah_key_pem_start, "-----END PRIVATE KEY-----", new_policy->ah_eph_key_path, 0600)) ok = 0;

	if (!ok) {
    	fprintf(stderr, "[AH_Policy] Failed to save ephemeral PEM files for IH %s. Aborting policy add.\n", ih_ip);
    	// Clean up potentially created files
    	remove(new_policy->ih_eph_cert_path);
    	remove(new_policy->ah_eph_cert_path);
    	remove(new_policy->ah_eph_key_path);
    	free(new_policy);
    	return 0;
	}

	// Add to linked list (thread-safe)
	pthread_mutex_lock(&g_policy_list_lock);
	// Remove any existing policy for the same IH IP first? Or allow multiple? Assume replace for now.
	ah_session_policy_t *existing = NULL, *prev = NULL;
	for(existing = g_session_policies; existing != NULL; prev = existing, existing = existing->next) {
    	if (strcmp(existing->ih_ip, ih_ip) == 0) {
         	printf("[AH_Policy] Replacing existing policy for IH %s\n", ih_ip);
        	if (prev) prev->next = existing->next;
        	else g_session_policies = existing->next;
        	// Free old policy resources (files, memory) - Call remove_session_policy helper
            // IMPORTANT: remove_session_policy should NOT free the structure itself here,
            // just remove files/rules. We free 'existing' below.
            printf("[AH_Policy] Cleaning up old policy resources for %s...\n", existing->ih_ip);
            remove(existing->ih_eph_cert_path);
            remove(existing->ah_eph_cert_path);
            remove(existing->ah_eph_key_path);
            run_iptables_rule_ah("-D", existing->ih_ip, existing->ah_mtls_listen_port, existing->ih_ip);
            free(existing); // Free the old policy struct memory
        	break; // Found and removed
    	}
	}

	// Add the new one to the front
	new_policy->next = g_session_policies;
	g_session_policies = new_policy;
	pthread_mutex_unlock(&g_policy_list_lock);

	printf("[AH_Policy] Policy added successfully for IH %s.\n", ih_ip);
	return 1;
}


// Find an active session policy by IH IP
ah_session_policy_t* find_session_policy(const char* ih_ip) {
	// Caller MUST lock g_policy_list_lock before calling and unlock after use
	ah_session_policy_t *current = g_session_policies;
	while (current != NULL) {
    	if (strcmp(current->ih_ip, ih_ip) == 0) {
        	// Check expiry? Can be done here or in cleanup thread.
        	// For SPA handler, maybe just check if it exists.
        	// if (time(NULL) < current->expiry_time) {
             	return current;
        	// }
    	}
    	current = current->next;
	}
	return NULL;
}

// Remove and free a specific policy entry (caller must hold lock)
// This function ONLY frees the struct memory. Files/rules are removed elsewhere.
void remove_policy_struct(ah_session_policy_t *policy_to_remove) {
    if (!policy_to_remove) return;
    printf("[AH_Policy] Freeing policy struct memory for IH %s\n", policy_to_remove->ih_ip);
    free(policy_to_remove);
}


// Free all policies (used during cleanup)
void free_all_session_policies() {
	pthread_mutex_lock(&g_policy_list_lock);
	ah_session_policy_t *current = g_session_policies;
	ah_session_policy_t *next;
    printf("[AH_Policy] Clearing all session policies...\n");
	while (current != NULL) {
    	next = current->next;
        printf("[AH_Policy] Cleaning up policy resources for %s...\n", current->ih_ip);
        remove(current->ih_eph_cert_path);
        remove(current->ah_eph_cert_path);
        remove(current->ah_eph_key_path);
        run_iptables_rule_ah("-D", current->ih_ip, current->ah_mtls_listen_port, current->ih_ip);
    	remove_policy_struct(current); // Free struct memory
    	current = next;
	}
	g_session_policies = NULL;
	pthread_mutex_unlock(&g_policy_list_lock);
	printf("[AH_Policy] All session policies cleared.\n");
}


// --- Policy Cleanup Thread ---
void* policy_cleanup_thread(void* arg) {
	(void)arg;
	printf("[AH_PolicyCleanup] Policy cleanup thread started.\n");
	while (!g_terminate_ah) {
    	sleep(CLEANUP_INTERVAL_SECONDS);
    	if (g_terminate_ah) break;

    	// printf("[AH_PolicyCleanup] Running policy check...\n"); // Reduce verbosity
    	time_t now = time(NULL);
    	pthread_mutex_lock(&g_policy_list_lock);
    	ah_session_policy_t *current = g_session_policies;
    	ah_session_policy_t *prev = NULL;
    	while (current != NULL) {
            // Expire policy ONLY if it's past expiry time AND not currently active
        	if (now >= current->expiry_time && !current->active) {
            	printf("[AH_PolicyCleanup] Expiring inactive policy for IH %s (Expired %ld sec ago)\n",
                   	current->ih_ip, (long)(now - current->expiry_time));
            	ah_session_policy_t *to_remove = current;
            	if (prev) {
                	prev->next = current->next;
                	current = current->next; // Advance current before removing
            	} else {
                	g_session_policies = current->next;
                	current = current->next; // Advance current before removing
            	}
                // Clean up files/rules associated with the policy
                printf("[AH_PolicyCleanup] Cleaning up expired policy resources for %s...\n", to_remove->ih_ip);
                remove(to_remove->ih_eph_cert_path);
                remove(to_remove->ah_eph_cert_path);
                remove(to_remove->ah_eph_key_path);
                run_iptables_rule_ah("-D", to_remove->ih_ip, to_remove->ah_mtls_listen_port, to_remove->ih_ip);
                // Free the struct memory
            	remove_policy_struct(to_remove);
            	// Don't increment prev here as we removed current
        	} else {
             	// Policy is still valid or active, move to next
             	prev = current;
             	current = current->next;
        	}
    	}
    	pthread_mutex_unlock(&g_policy_list_lock);
	}
	printf("[AH_PolicyCleanup] Policy cleanup thread exiting.\n");
	return NULL;
}

// --- SPA Listener Setup and Handler ---
// --- Wrapper for pcap_loop ---
void* pcap_thread_func(void* arg) {
	(void)arg;
	printf("[AH_SPA_Thread] pcap_loop starting...\n");
	// Loop indefinitely until pcap_breakloop is called or an error occurs
	int ret = pcap_loop(g_spa_pcap_handle, -1, spa_ah_packet_handler, NULL);
	printf("[AH_SPA_Thread] pcap_loop exited with code %d ", ret);
    if(ret == -1) { fprintf(stderr,"(%s)", pcap_geterr(g_spa_pcap_handle)); }
    else if (ret == -2) { fprintf(stderr,"(interrupted by pcap_breakloop)"); }
    fprintf(stderr,"\n");

    // Close pcap handle here after the loop finishes
    if (g_spa_pcap_handle) {
        pcap_close(g_spa_pcap_handle);
        g_spa_pcap_handle = NULL;
        printf("[AH_SPA_Thread] pcap handle closed.\n");
    }
	return NULL;
}

// --- Corrected SPA Listener Setup ---
int run_ah_spa_listener() {
	char errbuf[PCAP_ERRBUF_SIZE];
	char *dev = strdup(SPA_INTERFACE); // Use defined default
	if (!dev) { perror("strdup"); return 0; }

	printf("[AH_SPA] Using interface: %s for SPA listener\n", dev);

	bpf_u_int32 net, mask;
	struct bpf_program fp;

	if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
    	fprintf(stderr, "[AH_SPA] Warn: Couldn't get netmask: %s\n", errbuf);
    	net = 0; mask = 0;
	}

	g_spa_pcap_handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf); // Promiscuous mode = 1
	if (!g_spa_pcap_handle) {
    	fprintf(stderr, "[AH_SPA] Couldn't open device %s: %s\n", dev, errbuf);
    	free(dev); return 0;
	}
	free(dev); // Don't need dev string anymore

	if (pcap_datalink(g_spa_pcap_handle) != DLT_EN10MB) {
    	fprintf(stderr, "[AH_SPA] Warning: Non-Ethernet interface (%d)\n", pcap_datalink(g_spa_pcap_handle));
	}

	char filter_exp[100];
	snprintf(filter_exp, sizeof(filter_exp), "udp dst port %d", SPA_LISTENER_PORT);

    printf("[AH_SPA] Compiling filter: '%s'\n", filter_exp);
	if (pcap_compile(g_spa_pcap_handle, &fp, filter_exp, 0, net) == -1) {
    	fprintf(stderr, "[AH_SPA] Couldn't parse filter: %s\n", pcap_geterr(g_spa_pcap_handle));
    	pcap_close(g_spa_pcap_handle); g_spa_pcap_handle = NULL; return 0;
	}

    printf("[AH_SPA] Setting filter...\n");
	if (pcap_setfilter(g_spa_pcap_handle, &fp) == -1) {
    	fprintf(stderr, "[AH_SPA] Couldn't set filter: %s\n", pcap_geterr(g_spa_pcap_handle));
    	pcap_freecode(&fp); pcap_close(g_spa_pcap_handle); g_spa_pcap_handle = NULL; return 0;
	}

	pcap_freecode(&fp); // Free compiled filter after setting

	printf("[AH_SPA] SPA Server listening on UDP port %d (for Client Access)...\n", SPA_LISTENER_PORT);


	if (pthread_create(&g_spa_listener_tid, NULL, pcap_thread_func, NULL) != 0) {
    	perror("[AH_SPA] Failed to create SPA listener thread");
    	if(g_spa_pcap_handle) pcap_close(g_spa_pcap_handle);
    	g_spa_pcap_handle = NULL;
    	return 0;
	}

	return 1; // Success
}


// Packet handler for SPA packets coming from Clients (IH)
void spa_ah_packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) {
	const int ETH_HDR_LEN = 14;
	char source_ip_str[INET_ADDRSTRLEN];
	struct tm *tm_info; time_t now; char time_buf[30];

	(void)user_data; // Not using user data passed to pcap_loop

	now = time(NULL); tm_info = localtime(&now); strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", tm_info);
	// printf("\n[%s] AH_SPA Packet received (len %u)\n", time_buf, pkthdr->len); // Reduce verbosity

	// Basic Ethernet/IP/UDP header parsing
	if (pkthdr->caplen < (unsigned int)ETH_HDR_LEN) return;
	const struct ip *ip_header = (struct ip *)(packet + ETH_HDR_LEN);
	int ip_hdr_len = ip_header->ip_hl * 4;
	if (ip_hdr_len < 20) return; // Basic check for valid IP header length
	if (pkthdr->caplen < (unsigned int)(ETH_HDR_LEN + ip_hdr_len)) return;
	if (ip_header->ip_p != IPPROTO_UDP) return; // Only UDP
	const struct udphdr *udp_header = (struct udphdr *)((u_char *)ip_header + ip_hdr_len);
	int udp_hdr_len = sizeof(struct udphdr);
	if (pkthdr->caplen < (unsigned int)(ETH_HDR_LEN + ip_hdr_len + udp_hdr_len)) return;

	inet_ntop(AF_INET, &(ip_header->ip_src), source_ip_str, INET_ADDRSTRLEN);
	// printf("  Source IH IP: %s\n", source_ip_str);

	// --- Find Session Policy based on Source IP ---
	pthread_mutex_lock(&g_policy_list_lock);
	ah_session_policy_t *policy = find_session_policy(source_ip_str);
	if (!policy || time(NULL) >= policy->expiry_time) {
    	pthread_mutex_unlock(&g_policy_list_lock);
        // Only log if policy exists but is expired, otherwise too verbose
        if (policy) {
             printf("[AH_SPA] Discarding SPA from %s: Policy expired.\n", source_ip_str);
        } // else { printf("  -> Discarding: No active/valid session policy found for IH %s.\n", source_ip_str); }
    	return;
	}
	printf("[%s] AH_SPA: Active policy found for IH %s. Validating SPA...\n", time_buf, source_ip_str);
	// Keep lock until HOTP counter is potentially updated

	// --- SPA Processing (Using Ephemeral Keys from Policy) ---
	const u_char *payload = (u_char *)udp_header + udp_hdr_len;
	int payload_len = pkthdr->caplen - (ETH_HDR_LEN + ip_hdr_len + udp_hdr_len);
	if ((size_t)payload_len < SPA_PACKET_MIN_LEN || (size_t)payload_len > SPA_PACKET_MAX_LEN) {
    	pthread_mutex_unlock(&g_policy_list_lock);
    	printf("[AH_SPA] Discarding SPA from %s: Invalid payload len %d.\n", source_ip_str, payload_len); return;
	}

	const unsigned char *iv = payload;
	const unsigned char *encrypted_data = payload + SPA_IV_LEN;
	int encrypted_len = payload_len - SPA_IV_LEN - SPA_HMAC_LEN;
	const unsigned char *received_hmac = payload + SPA_IV_LEN + encrypted_len;
	if (encrypted_len <= 0) {
    	pthread_mutex_unlock(&g_policy_list_lock);
    	printf("[AH_SPA] Discarding SPA from %s: Invalid encrypted len %d.\n", source_ip_str, encrypted_len); return;
	}

	// --- 1. Verify HMAC (Ephemeral Key) ---
	// printf("  Verifying HMAC (Ephemeral)... "); // Verbose
	unsigned char calculated_hmac[EVP_MAX_MD_SIZE]; unsigned int calc_hmac_len = 0;
	const EVP_MD *digest = EVP_get_digestbyname(SPA_HMAC_ALGO); if (!digest) {pthread_mutex_unlock(&g_policy_list_lock); return; }
	unsigned char *data_to_hmac = malloc(SPA_IV_LEN + encrypted_len); // Allocate temporary buffer
    if (!data_to_hmac) { perror("malloc data_to_hmac"); pthread_mutex_unlock(&g_policy_list_lock); return; }
	memcpy(data_to_hmac, iv, SPA_IV_LEN); memcpy(data_to_hmac + SPA_IV_LEN, encrypted_data, encrypted_len);
	// Use policy's ephemeral HMAC key
	HMAC(digest, policy->spa_hmac_key, policy->spa_hmac_key_len, data_to_hmac, SPA_IV_LEN + encrypted_len, calculated_hmac, &calc_hmac_len);
    free(data_to_hmac); // Free buffer immediately after use

	if (calc_hmac_len != SPA_HMAC_LEN || constant_time_memcmp(received_hmac, calculated_hmac, SPA_HMAC_LEN) != 0) {
    	printf("[AH_SPA] Discarding SPA from %s: Invalid ephemeral HMAC.\n", source_ip_str);
    	pthread_mutex_unlock(&g_policy_list_lock); return;
	}
	// printf("OK\n"); // Verbose

	// --- 2. Decrypt Data (Ephemeral Key) ---
	// printf("  Decrypting data (Ephemeral)... "); // Verbose
	unsigned char decrypted_data[sizeof(spa_data_t)]; int decrypted_len = 0, final_len = 0; int decrypt_ok = 1;
	const EVP_CIPHER *cipher = EVP_get_cipherbyname(SPA_ENCRYPTION_ALGO); if (!cipher) {pthread_mutex_unlock(&g_policy_list_lock); return;}
	EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new(); if (!ctx) { handle_openssl_error("CTX New"); pthread_mutex_unlock(&g_policy_list_lock); return; }
	// Use policy's ephemeral ENC key
	if (1!=EVP_DecryptInit_ex(ctx, cipher, NULL, policy->spa_enc_key, iv)) { handle_openssl_error("DecryptInit"); decrypt_ok = 0; }
	if (decrypt_ok && 1!=EVP_DecryptUpdate(ctx, decrypted_data, &decrypted_len, encrypted_data, encrypted_len)) { ERR_clear_error(); decrypt_ok = 0; } // Ignore padding error here potentially
	if (decrypt_ok && 1!=EVP_DecryptFinal_ex(ctx, decrypted_data + decrypted_len, &final_len)) { ERR_clear_error(); decrypt_ok = 0; } // This catches padding errors
	EVP_CIPHER_CTX_free(ctx);
	if (!decrypt_ok) { printf("[AH_SPA] Discarding SPA from %s: Ephemeral decryption failed.\n", source_ip_str);
    	pthread_mutex_unlock(&g_policy_list_lock); return; }
	decrypted_len += final_len;
	// printf("OK (Plaintext size %d)\n", decrypted_len); // Verbose

	// --- 3. Validate Decrypted Payload & HOTP (Ephemeral) ---
	if ((size_t)decrypted_len != sizeof(spa_data_t)) {
    	fprintf(stderr, "[AH_SPA] Error: Decrypted size %d != expected %zu for SPA from %s.\n", decrypted_len, sizeof(spa_data_t), source_ip_str);
    	pthread_mutex_unlock(&g_policy_list_lock); return;
	}
	spa_data_t *spa_info = (spa_data_t *)decrypted_data;

	uint64_t received_timestamp = be64toh(spa_info->timestamp);
	uint64_t received_hotp_counter = be64toh(spa_info->hotp_counter);
	uint32_t received_hotp_code = ntohl(spa_info->hotp_code);
	uint8_t received_req_proto = spa_info->req_protocol; // Protocol/Port requested in SPA data
	uint16_t received_req_port = ntohs(spa_info->req_port); // Should match policy? Optional check.

	if (spa_info->version != SPA_VERSION) { fprintf(stderr, "[AH_SPA] Error: Invalid version %u from %s.\n", spa_info->version, source_ip_str); pthread_mutex_unlock(&g_policy_list_lock); return; }
	time_t current_time = time(NULL); int64_t time_diff = (int64_t)current_time - (int64_t)received_timestamp;
	if (llabs(time_diff) > SPA_TIMESTAMP_WINDOW_SECONDS) { fprintf(stderr, "[AH_SPA] Error: Timestamp invalid (Diff %llds > %ds) from %s.\n", (long long)time_diff, SPA_TIMESTAMP_WINDOW_SECONDS, source_ip_str); pthread_mutex_unlock(&g_policy_list_lock); return; }

	// Optional: Check if received req_proto/req_port match the policy
	if (received_req_proto != policy->service_proto || received_req_port != policy->service_port) {
    	fprintf(stderr, "[AH_SPA] Warn: SPA req %u/%u differs from policy %u/%u for IH %s.\n",
            	received_req_proto, received_req_port, policy->service_proto, policy->service_port, source_ip_str);
    	// Decide whether to reject or just warn. Let's warn for now.
	}

	// printf("  Timestamp/Version OK. Validating HOTP (Ephemeral)...\n"); // Verbose
	// printf("	Received Counter: %llu, Received Code: %0*u\n", (unsigned long long)received_hotp_counter, HOTP_CODE_DIGITS, received_hotp_code); // Verbose

	// HOTP Validation (Uses policy's ephemeral secret and counter)
	uint64_t expected_counter = policy->hotp_next_counter; // Get expected from policy
	int hotp_match = 0;
	uint64_t matched_counter = 0;

	// Check counter value is within reasonable range
	if (received_hotp_counter < expected_counter) {
        fprintf(stderr, "[AH_SPA]	HOTP Counter %llu too low (expected >= %llu) from %s.\n", (unsigned long long)received_hotp_counter, (unsigned long long)expected_counter, source_ip_str);
    } else if (received_hotp_counter > expected_counter + HOTP_COUNTER_SYNC_WINDOW) {
        fprintf(stderr, "[AH_SPA]	HOTP Counter %llu too high (expected <= %llu) from %s.\n", (unsigned long long)received_hotp_counter, (unsigned long long)(expected_counter + HOTP_COUNTER_SYNC_WINDOW), source_ip_str);
    }
     else {
        // Check only the received counter value against the calculated code
        uint32_t calculated_code = generate_hotp(policy->hotp_secret, policy->hotp_secret_len, received_hotp_counter, HOTP_CODE_DIGITS);
        // printf("	Checking Counter: %llu -> Calculated Code: %0*u\n", (unsigned long long)received_hotp_counter, HOTP_CODE_DIGITS, calculated_code); // Verbose
        if (calculated_code == received_hotp_code) {
            hotp_match = 1;
            matched_counter = received_hotp_counter;
            policy->hotp_next_counter = matched_counter + 1; // Update expected counter IN THE POLICY STRUCT
            printf("[AH_SPA]	HOTP MATCH FOUND at counter %llu! Updated policy next counter to %llu for %s.\n",
                   (unsigned long long)matched_counter, (unsigned long long)policy->hotp_next_counter, source_ip_str);
        }
    }
	// IMPORTANT: Unlock the policy list lock AFTER potential counter update
	pthread_mutex_unlock(&g_policy_list_lock);

	if (!hotp_match) {
    	fprintf(stderr, "[AH_SPA]	HOTP Validation FAILED for %s.\n", source_ip_str);
    	return;
	}
	// printf("  HOTP Validation OK.\n"); // Verbose

	// --- 4. Authorize Access to AH's Ephemeral mTLS Port ---
	printf("[AH_SPA] VALID Ephemeral SPA Packet from %s. Authorizing mTLS access to port %u...\n",
       	source_ip_str, policy->ah_mtls_listen_port);

	// Add iptables rule using the policy's listen port
	if (run_iptables_rule_ah("-I", source_ip_str, policy->ah_mtls_listen_port, source_ip_str) == 0) {
   	// Schedule removal of the rule
   	char *remove_cmd = NULL;
   	if (asprintf(&remove_cmd, "sh -c 'sleep %d && sudo iptables -D INPUT -s %s -p tcp --dport %u -m comment --comment \"SPA_ALLOW_%s\" -j ACCEPT > /dev/null 2>&1' &",
                	SPA_DEFAULT_DURATION_SECONDS, source_ip_str, policy->ah_mtls_listen_port, source_ip_str) != -1) {
       	printf("[AH_SPA]  Scheduling iptables cleanup: %s\n", remove_cmd);
       	system(remove_cmd); // Fire and forget
       	free(remove_cmd);
   	} else {
       	perror("[AH_SPA] asprintf failed for cleanup command");
   	}
	} else {
   	fprintf(stderr, "[AH_SPA] Failed to add iptables rule for %s to port %u\n",
           	source_ip_str, policy->ah_mtls_listen_port);
	}
	// printf("----------------------------------------\n"); // Verbose
}

// iptables rule helper for AH
int run_iptables_rule_ah(const char* action, const char* source_ip, uint16_t target_port, const char* comment_tag) {
	char *command = NULL;
	int ret;
	// Rule allowing TCP to the specified ephemeral mTLS port
	// Using a unique comment helps identify and delete the correct rule
	if (asprintf(&command, "sudo iptables %s INPUT -s %s -p tcp --dport %u -m comment --comment \"SPA_ALLOW_%s\" -j ACCEPT",
             	action, source_ip, target_port, comment_tag) == -1) {
   	perror("[AH_IPT] asprintf failed");
   	return -1;
	}
	printf("[AH_IPT] Executing: %s\n", command);
	ret = execute_command_ah(command); // Use AH's helper
	free(command);

	if (ret == 0) {
    	// printf("[AH_IPT] iptables %s rule for %s -> port %u successful.\n", action, source_ip, target_port); // Verbose
    	return 0; // Success
	} else {
    	fprintf(stderr, "[AH_IPT] iptables %s rule for %s -> port %u failed (status: %d)\n", action, source_ip, target_port, ret);
    	return -1; // Failure
	}
}

// --- Client mTLS Listener Setup ---
SSL_CTX* create_ah_client_ssl_context() {
	// This context needs to be dynamically configured per connection in the handler thread
	// based on the ephemeral certs/key from the policy.
	// So, we create a basic server context here, but loading specific certs happens later.

	SSL_CTX *ctx = create_ssl_context(1); // 1 = Server mode
	if (!ctx) return NULL;

	// Basic server config - Load CA to verify client certs
	if (SSL_CTX_load_verify_locations(ctx, g_ah_onboard_conf.ca_cert_path, NULL) != 1) {
    	fprintf(stderr, "[AH_mTLS] Failed loading CA: %s\n", g_ah_onboard_conf.ca_cert_path);
    	handle_openssl_error("SSL_CTX_load_verify_locations (Client Listener)");
    	SSL_CTX_free(ctx); return NULL;
	}

	// Require client cert, verification done in handler
	SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);
	// Set CA list for client cert request (helps client choose correct cert)
	STACK_OF(X509_NAME) *ca_list = SSL_load_client_CA_file(g_ah_onboard_conf.ca_cert_path);
    if (ca_list == NULL) {
        fprintf(stderr, "[AH_mTLS] Warning: Failed to load client CA list from %s.\n", g_ah_onboard_conf.ca_cert_path);
        // Continue, but client might have issues selecting cert
    }
	SSL_CTX_set_client_CA_list(ctx, ca_list); // Can be NULL if loading failed


	printf("[AH_mTLS] Base SSL Context for Client Connections created.\n");
	return ctx;
}

// --- Wrapper function for the client listener thread ---
void* client_listener_thread_func(void* arg) {
    (void)arg;
    printf("[AH_mTLS_Thread] Client listener thread started.\n");

    while (!g_terminate_ah) {
        struct sockaddr_in peer_addr;
        socklen_t peer_len = sizeof(peer_addr);
        int client_sock = -1;

        // Use select/poll on g_client_mtls_listen_sock for graceful shutdown
        fd_set read_fds; FD_ZERO(&read_fds);
        // Ensure socket is valid before adding to set
        if(g_client_mtls_listen_sock < 0) {
            printf("[AH_mTLS_Thread] Listener socket closed, exiting thread.\n");
            break;
        }
        FD_SET(g_client_mtls_listen_sock, &read_fds);
        struct timeval timeout; timeout.tv_sec = 1; timeout.tv_usec = 0;

        int activity = select(g_client_mtls_listen_sock + 1, &read_fds, NULL, NULL, &timeout);

        if (g_terminate_ah) break;
        if (activity < 0) {
            if (errno == EINTR) continue;
            if (errno == EBADF) break; // Socket closed by shutdown handler
            perror("[AH_mTLS_Thread] select accept");
            break; // Exit on error
        }
        if (activity == 0) continue; // Timeout

        // Accept connection if select indicated readiness
        client_sock = accept(g_client_mtls_listen_sock, (struct sockaddr*)&peer_addr, &peer_len);
        if (g_terminate_ah) { if(client_sock >= 0) close(client_sock); break;}
        if (client_sock < 0) {
            if (errno == EINTR || errno == EBADF || errno == EINVAL || errno == ECONNABORTED) continue; // Ignore transient or shutdown errors
            perror("[AH_mTLS_Thread] Accept failed");
            continue;
        }

        char peer_ip_str[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &peer_addr.sin_addr, peer_ip_str, sizeof(peer_ip_str));
        printf("[AH_mTLS_Thread] Accepted client connection from %s:%u (FD %d)\n", peer_ip_str, ntohs(peer_addr.sin_port), client_sock);

        // --- Find Policy for this Client ---
        pthread_mutex_lock(&g_policy_list_lock);
        ah_session_policy_t *policy = find_session_policy(peer_ip_str);
        if (!policy || time(NULL) >= policy->expiry_time) {
            pthread_mutex_unlock(&g_policy_list_lock);
            fprintf(stderr, "[AH_mTLS_Thread] No valid policy for connecting client %s. Closing.\n", peer_ip_str);
            close(client_sock);
            continue;
        }
        // Keep lock while preparing thread data

        // --- Create SSL object and configure with ephemeral certs ---
        SSL *ssl = SSL_new(g_client_mtls_ctx);
        if (!ssl) {
            handle_openssl_error("SSL_new client conn");
            close(client_sock);
            pthread_mutex_unlock(&g_policy_list_lock);
            continue;
        }

        // Configure THIS SSL object with the specific ephemeral cert/key for this session
        printf("[AH_mTLS_Thread] Configuring SSL for %s with cert %s\n", peer_ip_str, policy->ah_eph_cert_path);
        if (SSL_use_certificate_file(ssl, policy->ah_eph_cert_path, SSL_FILETYPE_PEM) <= 0) {
             fprintf(stderr,"[AH_mTLS_Thread] Failed to load ephemeral AH cert: %s\n", policy->ah_eph_cert_path);
             handle_openssl_error("SSL_use_certificate_file"); SSL_free(ssl); // closes client_sock
             pthread_mutex_unlock(&g_policy_list_lock); continue;
        }
        if (SSL_use_PrivateKey_file(ssl, policy->ah_eph_key_path, SSL_FILETYPE_PEM) <= 0) {
             fprintf(stderr,"[AH_mTLS_Thread] Failed to load ephemeral AH key: %s\n", policy->ah_eph_key_path);
             handle_openssl_error("SSL_use_PrivateKey_file"); SSL_free(ssl);
             pthread_mutex_unlock(&g_policy_list_lock); continue;
        }
        if (!SSL_check_private_key(ssl)) {
             fprintf(stderr,"[AH_mTLS_Thread] Ephemeral private key does not match the certificate\n");
             handle_openssl_error("SSL_check_private_key"); SSL_free(ssl);
             pthread_mutex_unlock(&g_policy_list_lock); continue;
        }

        SSL_set_fd(ssl, client_sock);


        // --- Prepare thread data ---
        ah_client_conn_data_t *thread_data = malloc(sizeof(ah_client_conn_data_t));
        if (!thread_data) {
            perror("[AH_mTLS_Thread] malloc thread data");
            SSL_free(ssl); // Closes underlying socket too
            pthread_mutex_unlock(&g_policy_list_lock);
            continue;
        }
        thread_data->ssl = ssl;
        strcpy(thread_data->peer_ip, peer_ip_str);
        thread_data->policy = policy; // Pass pointer to policy

        // Mark policy as active (prevents cleanup thread from removing it while tunnel is up)
        policy->active = 1;
        printf("[AH_mTLS_Thread] Policy for %s marked as active.\n", peer_ip_str);
        pthread_mutex_unlock(&g_policy_list_lock); // Unlock list *after* setting active flag

        // --- Spawn handler thread ---
        pthread_t tid;
        if (pthread_create(&tid, NULL, handle_client_connection_thread, (void*)thread_data) != 0) {
            perror("[AH_mTLS_Thread] pthread_create client handler failed");
            // Mark policy as inactive again since handler didn't start
             pthread_mutex_lock(&g_policy_list_lock);
             policy->active = 0;
             pthread_mutex_unlock(&g_policy_list_lock);
            free(thread_data);
            SSL_free(ssl); // Closes underlying socket
        } else {
            pthread_detach(tid); // Don't need to join handler threads
        }
    } // end while (!g_terminate_ah)

    printf("[AH_mTLS_Thread] Client listener thread exiting.\n");
    // Clean up listener socket (might already be closed by signal handler)
    if (g_client_mtls_listen_sock >= 0) {
         close(g_client_mtls_listen_sock);
         g_client_mtls_listen_sock = -1;
    }
     // Clean up listener context (should only be done once)
     // Let main cleanup handle this to avoid race conditions
    // if (g_client_mtls_ctx) {
    //    SSL_CTX_free(g_client_mtls_ctx);
    //     g_client_mtls_ctx = NULL;
    //}
    return NULL;
} // end client_listener_thread_func

// --- Start the Client mTLS Listener ---
int run_client_mtls_listener() {
	struct sockaddr_in addr;

	g_client_mtls_ctx = create_ah_client_ssl_context();
	if (!g_client_mtls_ctx) {
    	fprintf(stderr, "[AH_mTLS] Failed to create SSL context for client listener.\n");
    	return 0;
	}

	g_client_mtls_listen_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (g_client_mtls_listen_sock < 0) { perror("[AH_mTLS] Socket"); SSL_CTX_free(g_client_mtls_ctx); g_client_mtls_ctx=NULL; return 0; }

	int reuse = 1;
	if (setsockopt(g_client_mtls_listen_sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0) {
    	perror("[AH_mTLS] setsockopt(SO_REUSEADDR)");
    	// Continue anyway...
	}

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(AH_MTLS_PORT_DEFAULT); // Use default port for now
	addr.sin_addr.s_addr = htonl(INADDR_ANY);

	if (bind(g_client_mtls_listen_sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    	fprintf(stderr, "[AH_mTLS] Error binding listener port %d: %s\n", AH_MTLS_PORT_DEFAULT, strerror(errno));
    	close(g_client_mtls_listen_sock); g_client_mtls_listen_sock = -1;
    	SSL_CTX_free(g_client_mtls_ctx); g_client_mtls_ctx=NULL; return 0;
	}

	if (listen(g_client_mtls_listen_sock, SOMAXCONN) < 0) {
    	perror("[AH_mTLS] Listen");
    	close(g_client_mtls_listen_sock); g_client_mtls_listen_sock = -1;
    	SSL_CTX_free(g_client_mtls_ctx); g_client_mtls_ctx=NULL; return 0;
	}

	printf("[AH_mTLS] Server listening for Client mTLS on port %d...\n", AH_MTLS_PORT_DEFAULT);


	// Start the listener thread
	if (pthread_create(&g_client_mtls_listener_tid, NULL, client_listener_thread_func, NULL) != 0) {
    	perror("[AH_mTLS] Failed create client mTLS listener thread");
     	if (g_client_mtls_listen_sock >= 0) close(g_client_mtls_listen_sock);
    	if (g_client_mtls_ctx) SSL_CTX_free(g_client_mtls_ctx);
    	g_client_mtls_listen_sock=-1; g_client_mtls_ctx=NULL; return 0;
	}

	return 1; // Success starting thread
}

// --- Client mTLS Handler Thread ---
void* handle_client_connection_thread(void* arg) {
	ah_client_conn_data_t *data = (ah_client_conn_data_t*)arg;
	SSL *ssl = data->ssl;
	ah_session_policy_t *policy = data->policy; // Policy for this connection
	int client_sock_fd = SSL_get_fd(ssl); // Underlying socket
	int target_service_sock = -1;
	int ret;

	printf("[AH_ClientHandler %s] Handling connection...\n", data->peer_ip);

	// --- 1. Perform SSL Handshake ---
	printf("[AH_ClientHandler %s] Performing SSL_accept...\n", data->peer_ip);
    // Set timeout for handshake?
    // struct timeval handshake_timeout = { .tv_sec = 10, .tv_usec = 0 };
    // setsockopt(client_sock_fd, SOL_SOCKET, SO_RCVTIMEO, &handshake_timeout, sizeof(handshake_timeout));
    // setsockopt(client_sock_fd, SOL_SOCKET, SO_SNDTIMEO, &handshake_timeout, sizeof(handshake_timeout));
	ret = SSL_accept(ssl);
    // Remove timeout after handshake
    // struct timeval no_timeout = { .tv_sec = 0, .tv_usec = 0 };
    // setsockopt(client_sock_fd, SOL_SOCKET, SO_RCVTIMEO, &no_timeout, sizeof(no_timeout));
    // setsockopt(client_sock_fd, SOL_SOCKET, SO_SNDTIMEO, &no_timeout, sizeof(no_timeout));

	if (ret <= 0) {
    	int ssl_error = SSL_get_error(ssl, ret);
    	fprintf(stderr, "[AH_ClientHandler %s] *** SSL_accept FAILED [Code: %d] ***\n", data->peer_ip, ssl_error);
    	handle_openssl_error("SSL_accept client conn");
    	goto handler_cleanup;
	}
	printf("[AH_ClientHandler %s] SSL handshake successful. Version: %s Cipher: %s\n", data->peer_ip, SSL_get_version(ssl), SSL_get_cipher(ssl));

	// --- 2. Verify Peer Certificate against Policy ---
	X509 *peer_cert = SSL_get_peer_certificate(ssl);
	int cert_ok = 0;
	if (peer_cert) {
    	char cn_buf[256] = {0};
    	X509_NAME *subj = X509_get_subject_name(peer_cert);
    	if (X509_NAME_get_text_by_NID(subj, NID_commonName, cn_buf, sizeof(cn_buf)-1) > 0) {
         	// Check CN matches policy's expected IH IP AND the source IP of the TCP connection
         	if (strcmp(cn_buf, policy->ih_ip) == 0 && strcmp(cn_buf, data->peer_ip) == 0) {
             	printf("[AH_ClientHandler %s] Peer CN '%s' matches policy and source IP.\n", data->peer_ip, cn_buf);
             	cert_ok = 1;
         	} else {
             	fprintf(stderr, "[AH_ClientHandler %s] Peer CN '%s' mismatch! Policy IH: %s, Source IP: %s\n",
                     	data->peer_ip, cn_buf, policy->ih_ip, data->peer_ip);
         	}
    	} else {
         	fprintf(stderr, "[AH_ClientHandler %s] Could not get CN from peer certificate.\n", data->peer_ip);
    	}
    	X509_free(peer_cert);
	} else {
    	fprintf(stderr, "[AH_ClientHandler %s] No peer certificate received!\n", data->peer_ip);
	}

	if (!cert_ok) {
     	fprintf(stderr, "[AH_ClientHandler %s] Rejecting connection due to certificate validation failure.\n", data->peer_ip);
     	goto handler_cleanup;
	}
	printf("[AH_ClientHandler %s] Peer certificate validated successfully.\n", data->peer_ip);

	// --- 3. Connect to the actual backend service ---
	printf("[AH_ClientHandler %s] Connecting to backend service %s:%u...\n",
       	data->peer_ip, policy->target_service_ip, policy->target_service_port);

	int service_sock_type = SOCK_STREAM;
	int service_protocol = IPPROTO_TCP;
	if (policy->service_proto == 132) { // SCTP
     	printf("[AH_ClientHandler %s] Using SCTP for backend connection.\n", data->peer_ip);
     	service_sock_type = SOCK_STREAM; // Or SOCK_SEQPACKET depending on SCTP usage model
     	service_protocol = IPPROTO_SCTP;
	}

	target_service_sock = socket(AF_INET, service_sock_type, service_protocol);
	if (target_service_sock < 0) {
    	perror("[AH_ClientHandler %s] socket (backend)");
    	goto handler_cleanup;
	}
	struct sockaddr_in target_addr;
	memset(&target_addr, 0, sizeof(target_addr));
	target_addr.sin_family = AF_INET;
	target_addr.sin_port = htons(policy->target_service_port);
	if (inet_pton(AF_INET, policy->target_service_ip, &target_addr.sin_addr) <= 0) {
    	fprintf(stderr, "[AH_ClientHandler %s] Invalid target service IP %s\n", data->peer_ip, policy->target_service_ip);
    	close(target_service_sock); target_service_sock = -1;
    	goto handler_cleanup;
	}
	if (connect(target_service_sock, (struct sockaddr*)&target_addr, sizeof(target_addr)) < 0) {
    	fprintf(stderr, "[AH_ClientHandler %s] Failed to connect to target service %s:%u : %s\n",
            	data->peer_ip, policy->target_service_ip, policy->target_service_port, strerror(errno));
    	close(target_service_sock); target_service_sock = -1;
    	goto handler_cleanup;
	}
	printf("[AH_ClientHandler %s] Connected to backend service (FD %d).\n", data->peer_ip, target_service_sock);


	// --- 4. Relay Traffic ---
	printf("[AH_ClientHandler %s] Starting traffic relay...\n", data->peer_ip);
	relay_traffic(target_service_sock, ssl, policy->target_service_ip, policy->target_service_port);
	printf("[AH_ClientHandler %s] Traffic relay finished.\n", data->peer_ip);


handler_cleanup:
	printf("[AH_ClientHandler %s] Cleaning up handler thread...\n", data->peer_ip);
	// Mark policy as inactive (must hold lock)
	pthread_mutex_lock(&g_policy_list_lock);
	if (policy) { // Check policy still exists (might have been cleaned up?)
         // Find the policy again to ensure the pointer is still valid
         ah_session_policy_t *p = find_session_policy(policy->ih_ip);
         if (p == policy) { // Make sure it's the same policy struct
            printf("[AH_ClientHandler %s] Marking policy as inactive.\n", data->peer_ip);
            policy->active = 0;
            // Optionally reset expiry here if we want timeout to start AFTER disconnect
            // policy->expiry_time = time(NULL) + SESSION_POLICY_TIMEOUT_SECONDS;
         } else {
            printf("[AH_ClientHandler %s] Warning: Policy pointer seems invalid during cleanup.\n", data->peer_ip);
         }
	}
	pthread_mutex_unlock(&g_policy_list_lock);

	// Close sockets/SSL
	if (target_service_sock >= 0) {
    	close(target_service_sock);
	}
	if (ssl) {
    	SSL_shutdown(ssl); // Attempt clean shutdown
    	SSL_free(ssl); 	// Frees SSL structure and underlying socket FD (client_sock_fd)
	} else if (client_sock_fd >= 0) {
     	close(client_sock_fd); // Close raw socket if SSL wasn't fully setup
	}

	free(data); // Free thread data structure
	// Thread detaches itself in the listener loop
	return NULL;
}


// Relay traffic between plain socket (to service) and SSL socket (to client)
int relay_traffic(int service_fd, SSL* client_ssl, const char* target_ip, uint16_t target_port) {
	struct pollfd fds[2];
	char buffer[8192];
	int running = 1;
	int client_fd = SSL_get_fd(client_ssl);
    int poll_ret;

	// Set both sockets to non-blocking
	fcntl(service_fd, F_SETFL, O_NONBLOCK);
	fcntl(client_fd, F_SETFL, O_NONBLOCK);

	printf("[AH_Relay %s:%u] Starting relay: ClientFD=%d <-> ServiceFD=%d\n",
       	target_ip, target_port, client_fd, service_fd);

	while (running && !g_terminate_ah) {
    	fds[0].fd = client_fd; 	// mTLS connection from client
    	fds[0].events = POLLIN;
    	fds[0].revents = 0;
    	fds[1].fd = service_fd;	// Plain connection to backend service
    	fds[1].events = POLLIN;
    	fds[1].revents = 0;

    	poll_ret = poll(fds, 2, 1000); // 1 second timeout

    	if (g_terminate_ah) { running = 0; break; }
    	if (poll_ret < 0) {
        	if (errno == EINTR) continue;
        	perror("[AH_Relay] poll");
        	running = 0; break;
    	}
    	if (poll_ret == 0) continue; // Timeout

        int client_closed = 0;
        int service_closed = 0;

    	// --- Check Client (mTLS) -> Service (Plain) ---
    	if (fds[0].revents & (POLLIN | POLLERR | POLLHUP)) {
            // Keep reading until SSL_read returns WANT_READ or error/close
            while(running) {
                ssize_t bytes_read = SSL_read(client_ssl, buffer, sizeof(buffer));
                if (bytes_read > 0) {
                    ssize_t bytes_written = 0;
                    ssize_t total_written = 0;
                    while (total_written < bytes_read) {
                        bytes_written = write(service_fd, buffer + total_written, bytes_read - total_written);
                        if (bytes_written < 0) {
                            if (errno == EAGAIN || errno == EWOULDBLOCK) { usleep(1000); continue; }
                            perror("[AH_Relay] write to service"); running = 0; service_closed = 1; break;
                        }
                        if (bytes_written == 0) { fprintf(stderr, "[AH_Relay] write to service returned 0\n"); running = 0; service_closed = 1; break; }
                        total_written += bytes_written;
                    }
                     if(!running) break; // Break inner write loop if error
                } else {
                    int ssl_err = SSL_get_error(client_ssl, bytes_read);
                    if (ssl_err == SSL_ERROR_WANT_READ || ssl_err == SSL_ERROR_WANT_WRITE) {
                        break; // Done reading for now
                    } else {
                        if (ssl_err == SSL_ERROR_ZERO_RETURN) printf("[AH_Relay] Client closed mTLS connection cleanly.\n");
                        else if (ssl_err == SSL_ERROR_SYSCALL && bytes_read == 0) printf("[AH_Relay] Client closed connection (EOF).\n");
                        else { fprintf(stderr, "[AH_Relay] SSL_read from client error: %d\n", ssl_err); handle_openssl_error("Relay SSL_read"); }
                        running = 0; client_closed = 1;
                    }
                    break; // Break inner read loop on error or finish
                }
            } // end inner client read loop
        }
        if (!running && service_closed && !client_closed) { shutdown(client_fd, SHUT_WR); } // Signal service close to client

    	// --- Check Service (Plain) -> Client (mTLS) ---
        if (running && (fds[1].revents & (POLLIN | POLLERR | POLLHUP))) {
            // Keep reading until read returns EAGAIN or error/close
            while(running) {
                ssize_t bytes_read = read(service_fd, buffer, sizeof(buffer));
                if (bytes_read > 0) {
                    ssize_t bytes_written_ssl = 0;
                    ssize_t total_written_ssl = 0;
                    while(total_written_ssl < bytes_read) {
                        bytes_written_ssl = SSL_write(client_ssl, buffer + total_written_ssl, bytes_read - total_written_ssl);
                        if (bytes_written_ssl <= 0) {
                            int ssl_err = SSL_get_error(client_ssl, bytes_written_ssl);
                            if (ssl_err == SSL_ERROR_WANT_WRITE || ssl_err == SSL_ERROR_WANT_READ) { usleep(1000); continue; }
                            fprintf(stderr, "[AH_Relay] SSL_write to client error: %d\n", ssl_err); handle_openssl_error("Relay SSL_write");
                            running = 0; client_closed = 1; break;
                        }
                        total_written_ssl += bytes_written_ssl;
                    }
                    if (!running) break; // Break inner write loop if error
                } else {
                    if (bytes_read == 0) { printf("[AH_Relay] Backend service closed connection.\n"); }
                    else if (errno != EAGAIN && errno != EWOULDBLOCK) { perror("[AH_Relay] read from service"); }
                    else { break; } // EAGAIN/EWOULDBLOCK means done reading for now
                    running = 0; service_closed = 1;
                    break; // Break inner read loop on error or close
                }
            } // end inner service read loop
    	}
        if (!running && client_closed && !service_closed) { shutdown(service_fd, SHUT_WR); } // Signal client close to service


	} // end while(running && !g_terminate_ah)

	printf("[AH_Relay %s:%u] Relay loop terminated.\n", target_ip, target_port);
	return 0;
}


// --- Cleanup ---
void cleanup_ah_resources() {
	printf("[AH] Cleaning up AH resources...\n");

	// Signal threads to terminate (redundant if signal handler does it)
	g_terminate_ah = 1;

	// Stop SPA listener
	if (g_spa_pcap_handle) {
    	pcap_breakloop(g_spa_pcap_handle); // Request loop stop
	}
	if (g_spa_listener_tid) {
    	pthread_join(g_spa_listener_tid, NULL); // Wait for thread
    	printf("[AH] SPA listener thread joined.\n");
    	// pcap handle closed inside pcap_thread_func
    	g_spa_pcap_handle = NULL; // Mark as closed
	}


	// Stop Client mTLS listener
	if (g_client_mtls_listen_sock >= 0) {
         // Ensure socket is closed if not already by signal handler
         shutdown(g_client_mtls_listen_sock, SHUT_RDWR);
         close(g_client_mtls_listen_sock);
    	 g_client_mtls_listen_sock = -1;
	}
 	if (g_client_mtls_listener_tid) {
     	pthread_join(g_client_mtls_listener_tid, NULL);
     	printf("[AH] Client mTLS listener thread joined.\n");
 	}
 	if (g_client_mtls_ctx) {
     	SSL_CTX_free(g_client_mtls_ctx); g_client_mtls_ctx = NULL;
 	}

	// Stop Controller listener thread & close connection
	pthread_mutex_lock(&g_controller_ssl_lock);
	if (g_controller_ssl) {
    	SSL_shutdown(g_controller_ssl);
    	SSL_free(g_controller_ssl); // Frees socket too
    	g_controller_ssl = NULL;
	}
	pthread_mutex_unlock(&g_controller_ssl_lock);
	if (g_controller_listener_tid) {
     	// This thread might be blocked on select/read, needs signal/interrupt
     	// Join might hang if select doesn't unblock. Consider pthread_cancel as last resort.
     	pthread_join(g_controller_listener_tid, NULL);
     	printf("[AH] Controller listener thread joined.\n");
	}
 	if (g_controller_mtls_ctx) {
     	SSL_CTX_free(g_controller_mtls_ctx); g_controller_mtls_ctx = NULL;
 	}

	// Stop policy cleanup thread
	if (g_policy_cleanup_tid) {
    	pthread_join(g_policy_cleanup_tid, NULL);
    	printf("[AH] Policy cleanup thread joined.\n");
	}

	// Free remaining policies and remove rules/files
	free_all_session_policies();

	// Destroy mutexes
	pthread_mutex_destroy(&g_policy_list_lock);
	pthread_mutex_destroy(&g_controller_ssl_lock);

	// Cleanup OpenSSL
	cleanup_openssl();

	printf("[AH] AH Cleanup complete.\n");
}

// --- Main Orchestration ---
int main(int argc, char *argv[]) {
	(void)argc; (void)argv; // Not using args for now

	printf("[AH] Starting SDP Accepting Host...\n");

	// Need root for pcap and iptables
	if (geteuid() != 0) {
    	fprintf(stderr, "[AH] Error: This application requires root privileges (for pcap and iptables).\n");
    	return EXIT_FAILURE;
	}

	// Initialize OpenSSL
	initialize_openssl();

	// Setup signal handler
	struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = sigint_handler_ah;
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);


	// Load Config and State
	if (!load_ah_onboard_config(AH_ONBOARD_CONFIG, &g_ah_onboard_conf)) {
    	fprintf(stderr, "[AH] Fatal: Failed to load onboarding configuration.\n"); cleanup_openssl(); return EXIT_FAILURE;
	}
	if (!load_ah_state(AH_STATE_FILE, &g_ah_state)) {
     	// Logged in function, ensure state is initialized
     	g_ah_state.controller_hotp_counter = 0; // Ensure it's initialized
	}

	// --- Onboarding Step 1: SPA to Controller ---
	printf("[AH] --- 1: Sending Onboarding SPA -> Controller ---\n");
	g_ah_state.controller_hotp_counter++;
	int spa_r1 = send_spa_packet(g_ah_onboard_conf.controller_ip, SPA_LISTENER_PORT,
                            	g_ah_onboard_conf.enc_key,
                            	g_ah_onboard_conf.hmac_key, g_ah_onboard_conf.hmac_key_len,
                            	g_ah_onboard_conf.hotp_secret, g_ah_onboard_conf.hotp_secret_len,
                            	g_ah_state.controller_hotp_counter,
                            	0, 0); // 0/0 for registration
	if (spa_r1 != 0) {
    	g_ah_state.controller_hotp_counter--; // Decrement on failure
    	fprintf(stderr, "[AH] Fatal: Failed to send onboarding SPA packet to Controller %s.\n", g_ah_onboard_conf.controller_ip);
    	cleanup_ah_resources(); return EXIT_FAILURE;
	}
	save_ah_state(AH_STATE_FILE, &g_ah_state); // Save incremented counter
	sleep(1); // Allow time for firewall rule propagation

	// --- Onboarding Step 2: mTLS to Controller ---
	printf("[AH] --- 2: Establishing mTLS -> Controller ---\n");
	g_controller_mtls_ctx = create_ssl_context(0); // 0 = Client mode
	if (!g_controller_mtls_ctx) { cleanup_ah_resources(); return EXIT_FAILURE; }
	if (!configure_ssl_context(g_controller_mtls_ctx, g_ah_onboard_conf.ca_cert_path,
                           	g_ah_onboard_conf.client_cert_path, g_ah_onboard_conf.client_key_path, 0)) {
    	cleanup_ah_resources(); return EXIT_FAILURE;
	}

	pthread_mutex_lock(&g_controller_ssl_lock);
	g_controller_ssl = establish_mtls_connection(g_ah_onboard_conf.controller_ip,
                                             	CONTROLLER_MTLS_PORT, g_controller_mtls_ctx);
	pthread_mutex_unlock(&g_controller_ssl_lock);

	if (!g_controller_ssl) {
    	fprintf(stderr, "[AH] Fatal: Failed to establish mTLS connection to Controller %s:%u.\n",
            	g_ah_onboard_conf.controller_ip, CONTROLLER_MTLS_PORT);
    	cleanup_ah_resources(); return EXIT_FAILURE;
	}
	printf("[AH] mTLS connection to Controller established.\n");

	// --- Onboarding Step 3: Send AH_REGISTER ---
	printf("[AH] --- 3: Sending AH_REGISTER -> Controller ---\n");
	const char* register_msg = "AH_REGISTER\n";
	pthread_mutex_lock(&g_controller_ssl_lock);
	int sent = send_data_over_mtls(g_controller_ssl, register_msg);
	pthread_mutex_unlock(&g_controller_ssl_lock);
	if (sent <= 0) {
     	fprintf(stderr, "[AH] Fatal: Failed to send AH_REGISTER message to Controller.\n");
     	cleanup_ah_resources(); return EXIT_FAILURE;
	}

	// --- Start Listener Threads ---
	printf("[AH] --- 4: Starting Listener Threads ---\n");

	// Start Controller Listener Thread
	if (pthread_create(&g_controller_listener_tid, NULL, controller_listener_thread, NULL) != 0) {
    	perror("[AH] Failed create controller listener thread");
    	cleanup_ah_resources(); return EXIT_FAILURE;
	}

	// Start Policy Cleanup Thread
 	if (pthread_create(&g_policy_cleanup_tid, NULL, policy_cleanup_thread, NULL) != 0) {
    	perror("[AH] Failed create policy cleanup thread");
    	cleanup_ah_resources(); return EXIT_FAILURE;
 	}

	// Start SPA Listener (for clients)
	if (!run_ah_spa_listener()) {
    	fprintf(stderr, "[AH] Fatal: Failed to start SPA listener for clients.\n");
    	cleanup_ah_resources(); return EXIT_FAILURE;
	}

	// Start Client mTLS Listener
	if (!run_client_mtls_listener()) {
     	fprintf(stderr, "[AH] Fatal: Failed to start mTLS listener for clients.\n");
     	cleanup_ah_resources(); return EXIT_FAILURE;
	}

	// --- Main Loop ---
	printf("[AH] AH Initialization Complete. Running... (Press Ctrl+C to exit)\n");
	while (!g_terminate_ah) {
    	// Keep main thread alive. Could add monitoring or health checks.
    	pause(); // Wait for signals
	}

	// --- Shutdown ---
	printf("[AH] Shutdown signal received. Cleaning up...\n");
	cleanup_ah_resources();
	printf("[AH] AH Exiting.\n");
	return EXIT_SUCCESS;
}


